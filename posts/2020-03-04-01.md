# Inside look at modern web browser

## Part 1  [Reference link](https://developer.chrome.com/blog/inside-browser-part1?hl=zh-tw)

### Note
1. CPU (Central Processing Unit) like worder, and handle everything form math to art  
示意圖:  
![CPU](../public/img/posts/2020-03-04/01.png)


2. GPU (Graphics Processing Unit) handing simple tasks(rendering and smooth interaction) but across multiple cores at the same time.  
示意圖:
![GPU](../public/img/posts/2020-03-04/02.png)
示意圖:
![Application](../public/img/posts/2020-03-04/03.png)


3. A process can be described as an application's executing program.A thread is the one that lives inside of process and executes any part of its process's program. 

### Executing program on Process and Thread



4. 當啟動一個應用程式, 一個程序會被建立, 程序或許會建立一些執行序來幫助工作,但這是有需要才產生的(選項). 

   OS會給程序一個'slab'(記憶體區塊)用來工作,所有應用程會用來保持其狀態在此私有記憶體空間,當關閉應用程時,OS就會釋放此記憶體區塊.
示意圖:
![memory](../public/img/posts/2020-03-04/04.svg)

5. 一個程序可以要求OS在啟動另一個程序來執行不同的任務,當發生時,OS會分配不同的記憶體給此新程序,如果兩個程序之間要溝通,可透過IPC(Inter Process Communication).
   很多應用程式都被設計成此方式.當某個正在工作的程序反應遲鈍時,就可以重新啟動有問題的程序而不影響到其他正在運行的程序.
示意圖:
![IPC](../public/img/posts/2020-03-04/05.svg)

### Which process controls what?

6. Web Browser架構是使用一個程序加上很多執行序 或 很多程序對應一些執行序並透過IPC來相互溝通?
   建構遊覽器是沒有標準規格的.各個遊覽器使用的架構可能都不太一樣.
   Chrome的架構則是很多程序與一些執行序並使用IPC作之間的溝通,分成 
   * **Browser Process**:  控制'chrome'部分的application與address bar, bookmark, back , forward按鈕 等等.
   * **Utility Process**:  
   * **Renderer Process**: 控制整個tab內的網站內容顯示
   * **GPU Process**:      獨立process處理GPU的任務,它被分離在不同的process,因為GPU處理來自不同的application並繪製畫面在同一個介面.
   * **Plugin Process**:   控制網站對Plugin的使用,如flash.
   示意圖:
   ![sample](../public/img/posts/2020-03-04/06.png)

### The benefit of multi-process architecture in Chrome
   
7. 實際手動測試發現 Chrome 的程序有兩種狀態 :
    * 獨立的主Process與獨立的子Process(可能原本附屬在主Process,但主Process的tab被關閉了,所以自行獨立)
    * 獨立的主Process與附屬的子Process(例如:從主Process點擊裡面的連結另開tab來顯示網站內容,但若用滑鼠右鍵的'在新分頁開啟連結'則會開啟一個新的Process)

8. 可以假想每個tab都有自己的renderer process.
   ex: 
       假設有3個已經開啟網站的tab,可以當作每個tab獨立執行自己的render process, 若某一個tab反應延遲並將其關閉後也不影響其他tab的活動.
	   但若全部tab跑在同一個process下,當某一個tab反應延遲,所有的tab都會一起反應延遲.
   browser分離成多個 process 來工作的另一個好處是安全且可沙盒,由於OS提供限制Process權限功能,所以browser可以從某些功能中對某些process進行沙箱處理.
   例如 Chrome browser 限制任意用戶的Process(如: renderer process )對任意的檔案存取.
   因為Process有自己的私有記憶體空間,通常會包含常見的基礎設施副本(ex: V8 engine).這表示會耗費更多的記憶體,因為如果是同一Processs內的thread,他們將無法以他們自己的方式共享.
   為了節省記憶體,Chrome 限制了可啟動Process的數量.限制則依據device的記憶體和CPU,當Chrome達到限制時,會在同一個Process跑多個tab.
示意圖:
![animation](../public/img/posts/2020-03-04/07.png)

### Saving more memory - Servicification in Chrome

9. 同樣的方式適用於Browser Process. Chrome進行結構的更改.目的是將Browser上的每個 Program拆分到不同的process或合併從其他不同的process.(OS:有點像微服務的概念)
   一般的方式是當Chrome跑在很好的設備上,它可以將每個服務拆分成不同的Process,從而提供更穩定,但若Chrome在資源有限的device上,為了節省記憶體,Chrome 將多個服務整和入一個Process中.
   Android的平台也使用了類似的方式來整合Process以減少內存的使用.
示意圖:
![animation](../public/img/posts/2020-03-04/08.svg)

### Per-frame renderer processes - Site Isolation

[**Site Isolation**](https://developers.google.com/web/updates/2018/07/site-isolation) 是Chrome近期推出的功能, 可為每個跨網站的iframe運行在一個單獨的 render process.
之前討論的每個tab模型對應一個render process, 它是允許跨網站iframe在單個render process中運行,並且不同站點之間可共享記憶體.運行 a.com 和 b.com 在相同的render process似乎也OK.(OS:意思是指原本一個tab model只會有一個render process,但如過內崁iframe就會有多組render process 或使用相同的render process也OK?)
The [Same Origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) 是網站的核心安全模型.它確保網站內的資料在沒有獲得同意的情況下,不會被其他網站存取.針對安全攻擊的主要目標就是繞過此策略.Process isolation(進程隔離)是站點分離的最有效方法.
針對 [Meltdown and Spectre](https://developers.google.com/web/updates/2018/02/meltdown-spectre) 這點我們就更必須要分離網站所用的process.

桌機版的 Chrome 67就啟用站點分離(site isolation).
每個cross-site iframe在tab中取得獨立的render process,如下圖所示:  
![Diagram of site isolation; multiple renderer processes pointing to iframes within a site](../public/img/posts/2020-03-04/09.png)  
Figure 12: Diagram of site isolation; multiple renderer processes pointing to iframes within a site

啟用Site Isolation是經過多年努力的結果. Site Isolation不像分配不同的render process這麼簡單.它是從根本上改變iframe彼此交談的方式.
在不同process的iframe上打開devtools意味者devtools必須實現幕後工作才使其看起來是無縫接軌的.即使是按 Ctrl + F 來查找頁面的單詞, 這動作也表示者要搜索不同的render process.
Site Isolation是遊覽器的一個重要里程碑.

PS: Site Isolation:是一個安全防護用來防止惡意網站透過the Same-Origin Policy的bug來達到攻擊目的.他可確保來自不同網站的頁面總是會被放置到不同的process,每個都在沙盒內運行,這就可以限制Process所被允許的操作

### Wrap-Up 章節重點
1. 提到**遊覽器架構**與 **multi-process** 的架構
2. **Servicification**與**Site Isolation**討論更深層的multi-process架構

---

## Part 2 [Reference link](https://developer.chrome.com/blog/inside-browser-part2) 

### What happens in navigation
本章將更深入每個process和thread之間的溝通並顯示網站
一個簡易的範例: 
當你輸入URL到bowser,然後bowser從internet獲取數據並顯示到一個頁面上.
本章會專注於使用者起request一個網站然後遊覽器準備呈現此頁面,這也稱為**導航**.

### It starts with a browser process

![Browser UI at the top, diagram of the browser process with UI, network, and storage thread inside at the bottom](../public/img/posts/2020-03-04/10.png)

tab以外的每個東西都是browser process處理的.
Browser process 也有類似 UI thread用來繪製遊覽器的按鈕和輸入欄位.
the network thread which deals with network stack to receive data from the internet,the storage thread that controls access to the files and more.
When you type a URL into the address bar, your input is handled by browser process’s UI thread.

### A simple navigation

#### Step 1. Handing input
當使用者在網址列輸入內容,第一件事是UI thread需要問 **"這是搜尋查詢還是URL?"**
在Chrome上的網址列,他同時也是搜尋欄位,所以UI thread必須解析並決定是將輸入內容發送到搜索引擎還是發送請求到站點.

![UI Thread asking if the input is a search query or a URL](../public/img/posts/2020-03-04/11.png)

#### Step 2. Start navigation
當使用者點擊enter,UI thread會啟動網路調用以獲得站點內容,加載圖示(Loading spinner)顯示在tab的旁邊,然後network thread透過合適的protocol如DNS查找(DNS lookup)並建立TLS Connection for the request.

![the UI thread talking to the network thread to navigate to mysite.com](../public/img/posts/2020-03-04/12.png)

此時,network thread或許會收到server redirect header如 HTTP301.
這種情況下network thread會通知UI thread 對方server是要做一個請求重新定向(requesting redirect),然後將會啟動另一個URL request.

#### Step 3. Read response
當Response body開始進入,network thread會在必要時查看stream前面幾個bytes. Response的Content-Type必須說明此數據的類型是什麼.[MIME Type sniffing](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)會在這裡完成.但也有可能會丟失或錯誤,對於這個"tricky business"的相關[source code](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5),在comments裡面有說明各種不同遊覽器對待"content-type/payload"的方式.


![Response header which contains Content-Type and playload which is the actual data](../public/img/posts/2020-03-04/13.png)


若Response是HTML file,數據傳遞給render process.
若Response是Zip file,就表示是下載請求,那就將數據傳遞給download manager.
![Network thread asking if response data is HTML from a safe site](../public/img/posts/2020-03-04/14.png)

這也是[SafeBrowsing](https://safebrowsing.google.com/)檢查發生的地方.如果domain和response數據似乎匹配惡意網站,則network thread會發出警告並顯示一個警告頁面.
另外 [Cross Origin Read Blocking(CORB)](https://www.chromium.org/Home/chromium-security/corb-for-developers) 檢查是否發生是為了確保敏感的 cross-site data 不會進入render process.

#### Step 3. Find a renderer process
完成所有檢查且network thread確認遊覽器應該會導航到請求的網站,
network thread 會告訴UI thread數據已準備好了,然後UI thread會找到render process然後開始渲染網頁.

![Network thread telling UI thread to find Renderer Process](../public/img/posts/2020-03-04/15.png)

由於network request 可能需要幾百毫秒才能得到response,所以optimization會加速此過程.
當UI thread 送出一個URL request到network thread (Step 2),
他已經知道要導航到哪個網站.
UI Thread會在送出network request的同時並行地嘗試找或啟動一個render process.
若一切按預期進行,則當network thread接收到數據時,render process就會處於準備好的狀態.
若導航重新導向到不同的網站,此準備好的render process就可能不會使用,
這種情況下可能就需要另一個不同的process.

#### Step 4. Commit navigation
現在數據和render proces已經準備好了, IPC已經透過browser process送出. 因為是透過 stream data, 所以Render Process可持續接收HTML data.一旦browser process確認commit已在render process中發生,導航就會完成且document loading會就開始.

在此刻, address bar就會更新,security indicator(安全指示器)和site settings UI會反映新頁面的站點訊息. 此tab的session history將會更新, 因此back/forward按鈕將逐步遊覽剛導航的站點.

![IPC between the browser and the renderer processes, requesting to render the page](../public/img/posts/2020-03-04/16.png)

#### Extra Step. Initial load complete
一旦確認(提交)導航後,render process持續的加載資源與渲染頁面.
將會在下個章節講述發生什麼事情.一旦render process "完成"渲染,他會送出一個IPC回browser process(這是在所有"onload"事件觸發了頁面中所有的frames並完成執行之後). 此時, UI thread會停止tab上的loading spinner.

當我說"完成",因為client端JavaScript仍然可以載入額外的資源並且在之後呈現新的視圖.

![IPC from the renderer to the browser process to notify the page has "loaded"](../public/img/posts/2020-03-04/17.png)

### Navigating to a different site
剛剛上面的是簡單的導航,但如果user再次將不同的URL放到address bar會發生什麼事呢?
browser process會通過相同的步驟導航到不同的站點.
但在他做之前,若有"beforeunload"事件,就會先檢查當前render的站點.

"beforeunload"可以創建“離開這個網站嗎？”,當您嘗試導航或關閉tab時會發出警報。tab內所有的處理都是透過renderer process做(包含 JavaScript code),因此, 當新的導航request進來時,browser process就必須檢查目前的 renderer process.
> Caution: 不要添加沒有條件的"beforeunload"事件.否則會產生更多的延遲,因為處理器必須在導航可以被啟動之前先執行這樣的事件.應該只在需要時添加此事件處理程序("beforeunload"),例如: 若需要警告用戶他們可能會因為離開而丟失他們在頁面內輸入的內容.
 ![IPC from the browser process to a renderer process telling it that it's about to navigate to a different site](../public/img/posts/2020-03-04/18.png)
 
如果導航器從renderer process內被初始化(例如:使用者點擊link或clinet端JavaScript執行"window.location='https://newsite.com/'")此renderer process首先檢查"beforeunload"處理器.然後執行和browser process 初始化 navigation 一樣的過程.唯一的差異是navigation requestd開始從render process啟動傳到browser process.

當新的導航被建立用來到不同的網站,一個獨立的 render process 會被抓來處理此新的導航,同時保持當前 render process 過程,才能處理像是 **~unload~** 等等的事件.
[詳細的 page lifecycle state](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events)
[how you can hook into events with the Page Lifecycle API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api)

![IPCs from a browser process to a new renderer process telling to render the page and telling old renderer process to unload](../public/img/posts/2020-03-04/19.png)


### In case of Service Worker
[之前Service Worker的介紹](https://developers.google.com/web/fundamentals/primers/service-workers/)

Service worker 是一種在應用程序代碼中編寫network proxy的方式.
這允許web開發人員更好地**控制local cache內容**以及**何時從網路獲取新數據**.
若將service worker設置為從cache加載頁面,則無需從網路請求數據.

比較重要的部分是service worker是在render process中運行JavaScript Code. 但當導航請求進來時, browser process要如何知道此site有service worker呢?

![the network thread in the browser process looking up service worker scope](../public/img/posts/2020-03-04/20.png)

當serive worker被註冊後, 此serivce worker的範圍就會像一個參考點依樣一直保持者([可參考這篇The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)).
當導航發生時,network process會先根據domain註冊的service worker scope做查找.如果發現有註冊的service worker是針對此URL的,UI thread
就會找一個render process來執行service worker的code.
此service worker可能從cache載入數據,這樣可以消除從網路請求數據的需求,或者也可以從網路請求新的資源.

![the UI thread in a browser process starting up a renderer process to handle service workers; a worker thread in a renderer process then requests data from the network](../public/img/posts/2020-03-04/21.png)

### Navigation Preload
如果service worker最終決定從網路請求數據,則browser process和render process之前的往返可能導致延遲. [Navigation Preload](https://developers.google.com/web/updates/2017/02/navigation-preload)是一種透過與service worker並行加載資源來加速此過程的機制. 他用header標記這些請求,允許服務器決定為這些請求發送不同的內容.
例如: 只更新數據而不是整個document.

![the UI thread in a browser process starting up a renderer process to handle service worker while kicking off network request in parallel](../public/img/posts/2020-03-04/22.png)


### Wrap-up
在這篇文章中，我們研究了導航過程中發生的情況以及response header和客戶端JavaScript等Web應用程序代碼如何與瀏覽器交互作用。了解瀏覽器通過網絡獲取數據的步驟，可以更容易地理解為什麼開發導航預載等API。在下一篇文章中，我們將深入探討瀏覽器如何評估HTML / CSS / JavaScript以呈現頁面。


---

## Part 3 [Reference link](https://developer.chrome.com/blog/inside-browser-part3) 

[Reffer 2](https://medium.com/@liu8105203762/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AD%98%E9%AB%94%E7%B3%BB-%E5%9B%9B-renderer-process-7bd3b6ecd358)

### Inner workings of a Renderer Process
介紹了[multi-process architecture](https://developers.google.com/web/updates/2018/09/inside-browser-part1)架構和[navigation](https://developers.google.com/web/updates/2018/09/inside-browser-part2)流程。在這篇文章中，我們將看看渲染器進程內部發生了什麼。

若要更深入可參考[the Performance section of Web Fundamentals](https://developers.google.com/web/fundamentals/performance/why-performance-matters/).

### Renderer processes handle web contents
Render process 負責 tab 內所有發生的事情. 在 render process 中, main thread 處理您送給用戶的大部分code. 
如果是使用 web worker 或 service worker, 有時JavaScript的一部分將由 worker thread 處理.
Compositor 和 raster thread 也在 render process 內運行, 並以高校,流暢地呈現頁面.
Render process的核心工作是將HTML, CSS, JavaScript轉換為可以和用戶
交互作用的網頁.
![Renderer process with a main thread, worker threads, a compositor thread, and a raster thread inside](../public/img/posts/2020-03-04/23.png)

### Parsing

#### Construction of a DOM
當render process透過navigation收到一個確認的訊息並開始接受HTML data, main thread開始轉換text string(HTML)並把它變成一個 Document Object Model(DOM).

**DOM**是遊覽器頁面內部結構的表示,開發人員可以透過JavaScript調用API來交互作用.

[HTML Standard](https://html.spec.whatwg.org/)則是將HTML document轉換成DOM的定義規範.
您可能已經注意到將HTML提供給瀏覽器永遠不會引發錯誤。
例: 
假設漏失關閉tag \</p> 時仍是有效的HTML. 
或像是 **Hi! \<b>I'm \<i>Chrome\</b>!\</i>** (tag b 比 tag i 還早關閉)
會被視為 **Hi! \<b>I'm \<i>Chrome\</i>\</b>\<i>!\</i>**
這是因為HTML規範旨在優雅地處理這些錯誤。如果你很好奇這些事情是如何完成的，你可以繼續閱讀HTML Spec的[ "An introduction to error handling and strange cases in the parser"](https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser)章節

#### Subresource loading
網站通常使用images, CSS, JavaScript 等等的外部資源.
載入這些檔案必須透過網路或緩存. 
在解析並建構DOM時, main thread可以用一個一個的方式來發送request,但為了加速, "preload scanner"會並行運行. 若HTML document內有像是 \<img> 或 \<link>這樣的東西, "preload scanner" 會讓HTML parser  peek產出一個token並在瀏覽器process中向network thread發送請求.
![The main thread parsing HTML and building a DOM tree](../public/img/posts/2020-03-04/24.png)

#### JavaScript can block the parsing
當HTML解析器找到 **\<script\>** tag時,他會暫停解析HTML文檔,並開始加載與執行此JavaScript代碼. 
為什麼呢? 因為JavaScript能夠變更文檔的內容,例如 **document.write()** ,這會變更整個DOM結構([(overview of the parsing model](https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model)). 
這就是為何HTML解析器在重新解析HTML文檔之前必須等待JavaScript運行的原因.JavaScript執行期間發生的事可以參考這個[ the V8 team has talks and blog posts on this](https://mathiasbynens.be/notes/shapes-ics).

#### Hint to browser how you want to load resources(提示遊覽器如何加載資源)
Web開發人員可以透過很多方式向遊覽器發送提示,以便更好的加載資源.
若沒有JavaScript內沒有使用 *document.write()* , 可以加入 **async** 或 **defer** 屬性到 **script**標籤內.
然後遊覽器將非同步地加載與運行JavaScript代碼,並且不會暫停解析流程.
ˇ某些情境也可使用 [JavaScript module](https://v8.dev/features/modules).
\<link rel="preload"\> 是一種通知瀏覽器當前navigation絕對需要該資源的方法.詳細可參考[Resource Prioritization – Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization)

#### Style calculation
擁有DOM不足以知道頁面的外觀, 因為我們可以在CSS中設置頁面元素的樣式.
main thread 解析CSS並確定每個DOM節點的計算樣式. 這是有關基於CSS selector 將哪種樣式套用到哪個元素的訊息. 可以在chrome DevTools內的 *Computed* 區塊看到計算後的樣式.

![The main thread parsing CSS to add computed style](../public/img/posts/2020-03-04/25.png)

即使不提供任何CSS,每個DOM節點也會有一個計算後的樣式. h1標籤顯示上會比h2大且每個元素都定義了margin,這是因為每個遊覽器都有一個默認的樣式表.[chrome default style sheet used to render HTML](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/html/resources/html.css)

#### Layout
現在 render process 知道 document 內的每個節點樣式, 但還不足以渲染到頁面. 想像一下若你試者透過電話向你朋友描述一幅畫, 只說"有一個大紅色圓圈和一個小藍色方塊", 這樣的資訊不足以讓他知道畫裡面的樣子.
![A person standing in front of a painting, phone line connected to the other person](../public/img/posts/2020-03-04/26.png)

Layout 是查找元素幾何形狀的過程. Main thread會遍歷DOM和計算後的style並建立包含像是 x, y 軸資訊或邊框尺寸的 layout tree.
Layout tree 結構類似 DOM tree,但他僅包含與頁面上可見內容有關的信息.
若 **"display: none"** 被套用, 則此元素就不屬於 layout tree(當元素style是 **"visibility: hidden"** 仍然會屬於 layout tree). 
同樣地,若帶有內容的偽類別像是 **"p::before{content: "Hi!"}"** 被應用, 它就會被包含在 layout tree, 即使它不在DOM中.


![The main thread going over DOM tree with computed styles and producing layout tree](../public/img/posts/2020-03-04/27.png)
[Figure 5: The main thread going over DOM tree with computed styles and producing layout tree]

![影片參考]: https://developer.chrome.com/static/blog/inside-browser-part3/video/T4FyVKpzu4WKF1kBNvXepbi08t52/rXSCtc21M00XrRqcw56C.mp4

[Page Jank](https://www.afasterweb.com/2015/08/29/what-the-jank/) : 是指使用者在頁面上有任何動作(例如:scroll滾動或animation或transition)時遇到任何卡頓或斷斷續續的情況



