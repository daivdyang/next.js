# TypeScript - React (Refactor) 


參考影片  
Ref: https://www.youtube.com/watch?v=hBk4nV7q6-w

作者
https://www.mattpocock.com/

## 抽象化表單(generic table component)
情境是當 `Table` 有多種型態資料, 針對Table作抽象化,使得 `Table` 組件可以重用.  
範例代碼:
```typescript=
interface TableProps {
    items: { id: string }[];
    renderItem: (item: { id: string }) => React.ReactNode;
}

export const Table = (props: TableProps) => {
    return null;
};

export const Component = () => {
    return (
      <Table
        items={[{ id: 1 }]}
        renderItem={(item) => {
          return null;
        }}
      ></Table>
    );
}
```

首先看到 `{ id: ... }` 這東西是通用性(generic)的, 所以將這類的東西抽取出來變共通性類型.  
使用泛型來取代, 故用 `Titem` 來表示此項目,所以將 `Table` 內的 `TableProps` 的 `items` 項目的類型往外抽出,
在TS中,這是告訴TS說我想知道這是什麼類型,然後我就能繼續操作,修改如下:  
```typescript=
interface TableProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
}

export const Table = <Titem>(props: TableProps<Titem>) => {
    return null;
};
```

當調整後發生了甚麼事?  
當新增 `items` 內的欄位, 則 `renderItem` 的 `item` 也跟者改變.  
意思是當傳遞的參數類型從 `items` 帶入會一併影響到 `renderItem` 內的欄位.  
修改如下:
```typescript=
export const Component = () => {
    return (
      <>
        {/* 第一種 Table 類型 */}
        <Table
          items={[{ id: 1, firstName: 'Burke' }]}
          renderItem={(item) => {
            // can handle the "item.firstName" with TypeScript
            return null;
          }}
        ></Table>
        {/* 第二種 Table 類型 */}
        <Table
          items={[{ id: 1, name: 'Bandit' }]}
          renderItem={(item) => {
            // can handle the "item.name" with TypeScript
            return null;
          }}
        ></Table>
      </> 
    );
}
```

## 取得物件深層欄位的值類型(get deep value)

嘗試讓一個函式可以查看任何類型的對象並且從對象內部獲取正確的值"型別",  
例如取得 `obj.foo.a` 返回 `true` 類型或 `boolean`類型.  
範例如下:  
```typescript=
export const getDeepValue = (
    obj: any,
    firstKey: string,
    secondKey: string
) => {
    return obj[firstKey][secondKey];
};

const obj = {
    foo: {
        a: true,
        b: 2,
    },
    bar: {
        c: "12",
        d: 18,
    }
};

const value = getDeepValue(obj, "foo", "a");
```

使用類似 `generic` 的方式將 `obj` 抽取出來, 這時將游標移至 `getDeepValue` 會發現`TObj` 已被判定為 `obj` 的類型, 但宣告的 `getDeepValue` 內的錯誤還未處理
![展示TS自動判斷的TObj](https://i.imgur.com/WWTwhf9.png)

修改如下:
```typescript=
export const getDeepValue = <TObj,>(
    obj: TObj,
    firstKey: string,
    secondKey: string
) => {
    return obj[firstKey][secondKey];
}
// 游標移至 getDeepValue 會發現 TObj 已經被TS判定為傳入的物件類型
const value =  getDeepValue({ bar: { a: 123 }}, "bar", "a"); // getDeepValue<{ bar: { a: number }}>
const value2 = getDeepValue({ foo: { a: "test" }}, "foo", "a");// getDeepValue<{ bar: { a: string }}>
```

[Ref Link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBA5gUygEQQgDgNQIYBsCuCMAvDADwAqA8gEYBWANAHwAUAUDJzCPQFwzV6DDlwBmASwBO0ANIIAnv2iTxYOMK4wICUGAAmcxVqgq1bAJQkmMAN4jOkpPklhu9ANoTpUQwF132roGCr4A3GwAvuFsutBudCS29jCiICD8dpqa2PwmhBpZnDT8AEwFnBHlMDTYkhnJmsD8AEQAjCXNVZp6-K0AHFURkdGxsABueISJiChoWJMILDyMMM2pIJ2r2M3m4aMwEwQIJdNIqBg4Ryw2KWkZMDmrUAjQzTARlavrm83bu0A)

接下來處理 `firstKey` 的問題, 首先錯誤內容是說無法使用 `index` 的方式去存取一個 `unknow` 類型.  
所以將 `firstKey` 的類型改成 `keyof TObj` 表示 `key` 的來原是從 `TObj` 來的,  
TS從泛型獲得對象的`Key`,所以TS會列舉有哪一些Key是可用的,這時就可以判定輸入的 `firstKey` 是否正確.  
接下來第二個欄位Key是依據第一個欄位之後判定的,  
所以將 `firstKey` 抽取出來當泛型的第2個類型參數,  
並且設定限制(extends keyof TObj)來表示 `TFirstKey` 類型是從 TObj 的 `Key` 擴展的.  
然後再設定`secondKey` 抽取出來當泛型的第3個類型參數,  
並且設定限制(extends keyof TObj\[TFirstKey\])來表示 `TSecondKey` 類型是從 TObj\[TFirstKey\] 的 `Key` 擴展的.  
這時TS的判定推導就會依據層級一層一層檢查

修改如下:
```typescript=
export const getDeepValue = <
  TObj, 
  TFirstKey extends keyof TObj,
  TSecondKey extends keyof TObj[TFirstKey]    
>(
    obj: TObj,
    firstKey: keyof TObj,
    secondKey: string
) => {
    return obj[firstKey][secondKey];
};

const obj = {
    foo: {
        a: true,
        b: 2,
    },
    bar: {
        c: "12",
        d: 18,
    }
};

const value =  getDeepValue(obj, "bar", "d"); // return number type
const value2 = getDeepValue({ foo: { a: "test" }}, "foo", "a");// return string type
```

[Ref Link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBA5gUygEQQgDgNQIYBsCuCMAvDADwAqA8gEYBWANBQGICWATtANIICeMCAB5QEYACYQYAaz4gAZjGr0mAZQShxPfkJHjJM3vMW06AbRYdufALoA+ABQAoGC5gh6ALmPLnruZagtLwtOQL4GXxcIdXAxIMU1DTi+RwBKElsYAG9ImHYkfHYwN3pTf1Cta1NopMqAbkcAXwbHDWgSuhJs3LkQEC8c1yGYbC8odkII4dcaLwAmKddGxZcabHYB3KHgLwAiAEY53ZXhsS99gA4TxqaWttgANzxCLsQUNCxnhHt3RhhdtbsY7-MS7VINe4wJ4EBBzV5IVAYHAw+xZGC9frZEZ7ETQXYwRrLf4Y4G7bBgupAA)

## using 'Zod' to checking type at runtime
當想要檢查型別,但來源是某些APi或不受控制的lib,可以使用 `zod` 來幫忙檢查(runtime check).  
目的是希望當型別檢查有問題就提早出現問題,別將問題繼續傳播下去.
```javascript=
import { z } from 'zod';

// 宣告 data 的數據類型,提供runtime時檢查
const Data = z.object({
  id: z.number(),
  name: z.string()  
});

// 2. 透過Type定義來提供於TS中使用
type DataType = z.infer<typeof Data>

// 假設API返回數據與定義的類型一致,檢查就會通過
Promise.resolve({ id: 123, name: "test"})
    .then(res => res.json())
    .then(result => {
        // 透過定義的Data變數來幫忙在runtime檢查是否符合期望
        const data = Data.parse(result);
    })

// 假設API返回數據與定義的類型不一致,檢查後就會拋出異常
Promise.resolve({ id: 123, name: true })
    .then(res => res.json())
    .then(result => {
      try {
        // 透過定義的Data變數來幫忙在runtime檢查是否符合期望,因為型別不符合所以拋出異常
        const data = Data.parse(result);   
      } catch (e) {
        console.log('error', e);
        /* ZodError: [
            {
              "code": "invalid_type",
              "expected": "string",
              "received": "boolean",
              "path": [
                "name"
              ],
              "message": "Expected string, received boolean"
            }
          ] 
        */
      }
    })
```

大部分情境可使用 interface
但還是會使用type的情況
例如:
```typescript=

type MyString = string


```
## (conditional types)



## (loose autocomplete)

## (compose)

## (conditional function args)

## (distributive conditional types)

## (object values)

## (error message in ts)
比較通常有兩種情況,就是相同或不同,但若要表達無法比較呢?
當兩者無法比較就拋出異常,在TS中用 `never` 表示

以下範例是runtime時才做型別檢查
```typescript=
export const deepEqualCompare = <Arg>(
  a: Arg,
  b: Arg
): boolean => {
  if (Array.isArray(a) || Array.isArray(b)) {
      throw new Error(
        "You cannot compare two arrays using deepEqualCompare"
      );
  }
    
  return a === b;
}
```
以上也可將檢查移至類型檢查,如下:
```typescript=
export const deepEqualCompare = <Arg>(
  a: Arg extends any[] ? `don't pass any array!` : Arg,
  b: Arg extends any[] ? `don't pass any array!` : Arg
): boolean => {    
  return a === b;
}

deepEqualCompare("a", "b");// pass
deepEqualCompare([], []); // 編譯時期就會拋出異常 : Argument of type 'string[]' is not assignable to parameter of type '"don't pass arrays!"' 
```
[Ref Link](https://www.typescriptlang.org/play?&filetype=ts#code/MYewdgzgLgBAJgUwQBwKIEcCuBDANgYRAFtlsAnBGAXhgB4BBMgcwBoA+ACgCgYZsAuGI1Y8YAI0HCuASkFiQIXAmxhqbGAG9RASwBmMDozLYAngDptEI6Y7ZpMAD4OhZY+cvWTHMdPtbevFAAFmQgAO4wYAgRqK4gZNwBAQBEAJogmDDAKmAgsKAk5JRQYSB8rqYQMJgQ2mBM8EhoWHiEhRTJorzSANyiAL6iFFCYZKrY1FQ0Yn39fVxciCgYOATEpBQcydjJLDDJYsm9i00rretFHADaB8kAuns3O3fHXKCQsEvNq20bCABM1DownYiT4kmYMAQAA8oAgwHAqioTFc7jAAPwwAAGcHAAHJYKQIEiKiYIABCLEwCEiXgSFwNGFwhFIsAotGYnH4wnYYnlNwUqk0mRyBRKFRqTQ6fSGUkWKyk2z2JwuNzyzzeXxSpLBUIRKIxOIJLopdKZbJgXL5C4UGAlMrkAXVWr1RrLFprdoITpJY68Qa8YajcaTaazeYnd0-G0ArY7Pa3Y5fM6ev7-a63B4wJ73XpAA)

## (search params decoding)
從一個字串來獲取一系列的query參數, 使用 `tts-toolbelt` 庫來幫助轉換
```typescript=
import { String, Union } from 'ts-toolbelt';

const query = `/home?a=foo&b=wow`;

type Query = typeof query;

// 取得"?"之後的字串 => SecondQueryPart 類型是 'a=foo&b=wow'
type SecondQueryPart = String.Split<Query, "?">[1];

// 將字串切割,切割符號為"&" 所以將返回的數據類型是一個陣列
// QueryElements 類型是 ['a=foo', 'b=wow']
type QueryElements =String.Split<SecondQueryPart, "&">;

type Key = String.Split<QueryElements[0], "=">[0];
type Value = String.Split<QueryElements[0], "=">[1];

// 將 QueryElements 分離並跑loop 最後在將loop內的結果返回
// loop內所跑的是依據"="分離字串 'a=foo' 會返回 ['a', 'foo'], 然後將index 0的值當Key, index 1 的值當Value
type QueryParams = {
    [QueryElement in QueryElements[number]]: {
        [Key in String.Split<QueryElement,"=">[0]]: String.Split<QueryElement, "=">[1];
    };
}[QueryElements[number]];
// QueryElement 表示 'a=foo' 或 'b=wow' 其中之一
// 最後需要透過[QueryElements[number]] 來返回值的部分
// QueryParams 類型是 { a: "foo" } | { b: "wow" }


// 最後用Union.Merge將兩種物件合併在一起
const obj = Union.Merge<QueryParams> = {
    a: "foo",
    b: "wow"
}
```


## 基本問題

1. explain `keyof`

```typescript=
interface Letters {
    a: string;
    b: string;
    c: string;
}

type LettersAsUnion = keyof Letters;// 'a' | 'b' | 'c'

const letter: LettersAsUnion = 'c';
```

2. explain 
```typescript=
interface Letters {
    a: number;
    b: string;
    c: {
      name: string;
    };
}

// the 'LettersValues' type is { name: string } | number
type LettersValues = Letters['c' | 'a'];

```